{-# LANGUAGE CPP, FlexibleInstances, TypeSynonymInstances #-}

------------------------------------------------------------------------------
-- Pretty printer for TPTP
------------------------------------------------------------------------------

module TPTP.Pretty where

-- Haskell imports
import Data.Char ( isAlphaNum, ord, toUpper, toLower )

-- Agda library imports
import Agda.Syntax.Abstract ( Name, ModuleName(..), QName(..))
import Agda.Utils.Impossible ( Impossible(..) , throwImpossible )

-- Local import
import FOL.Types
import TPTP.Types ( AnnotatedFormula(..), RoleTPTP(..) )
#include "../undefined.h"

------------------------------------------------------------------------------

type TPTP = String

class PrettyTPTP a where
    prettyTPTP :: a -> TPTP

instance PrettyTPTP Char where
    prettyTPTP c | isAlphaNum c = [c]
                 | otherwise    = show $ ord c

------------------------------------------------------------------------------
-- Pretty-printer for Agda types.
instance PrettyTPTP Name where
    prettyTPTP name = concat $ map prettyTPTP $ show name

instance PrettyTPTP ModuleName where
    prettyTPTP (MName names) = concat $ map prettyTPTP names

instance PrettyTPTP QName where
    prettyTPTP (QName moduleName name) =
        "agda" ++ prettyTPTP moduleName ++ "_" ++ prettyTPTP name

------------------------------------------------------------------------------
-- Pretty-printer for FOL formulas.

-- We use this instance because the names on the FOL formulas was
-- generated by a 'show qname'. Therefore, we need removed the
-- non-valid TPTP symbols. N.B. This instance require the flag
-- TypeSynonymInstances.
instance PrettyTPTP String where
    prettyTPTP s = concat $ map prettyTPTP s

instance PrettyTPTP TermFOL where
    prettyTPTP (FunFOL name [])    = prettyTPTP name
    prettyTPTP (FunFOL name terms) = prettyTPTP name ++ "(" ++ prettyTPTP terms ++ ")"
    prettyTPTP (VarFOL name)       = map toUpper name
    prettyTPTP (ConstFOL name)     = map toLower name

instance PrettyTPTP [TermFOL] where
    prettyTPTP [] = []
    prettyTPTP (a : []) = prettyTPTP a
    prettyTPTP (a : as) = prettyTPTP a ++ "," ++ prettyTPTP as

instance PrettyTPTP Formula where
    -- We translate the hard-code FOL predicate kEqual as the
    -- predefined equality in the ATP.
    prettyTPTP (Predicate "kEqual" [t1, t2] ) =
       "( " ++ prettyTPTP t1 ++ " = " ++ prettyTPTP t2 ++ " )"

    prettyTPTP (Predicate "kEqual" _) = __IMPOSSIBLE__

    prettyTPTP (Predicate name terms) =
        prettyTPTP (map toLower name) ++ "(" ++ prettyTPTP terms ++ ")"

    prettyTPTP (And f1 f2) =
        "( " ++ prettyTPTP f1 ++ " & " ++ prettyTPTP f2 ++ " )"
    prettyTPTP (Or f1 f2) =
        "( " ++ prettyTPTP f1 ++ " | " ++ prettyTPTP f2 ++ " )"

    prettyTPTP (Not f) = "~" ++ prettyTPTP f

    prettyTPTP (Implies f1 f2) =
        "( " ++ prettyTPTP f1 ++ " => " ++ prettyTPTP f2 ++ " )"

    prettyTPTP (Equiv f1 f2) =
        "( " ++ prettyTPTP f1 ++ " <=> " ++ prettyTPTP f2 ++ " )"

    prettyTPTP (ForAll var f) =
        "( ! [" ++ (map toUpper var) ++ "] : " ++
                    "( " ++ (prettyTPTP $ f (VarFOL var)) ++ " )" ++
        " )"

    prettyTPTP (Exists var f) =
        "( ! [" ++ (map toUpper var) ++ "? : " ++
                    "( " ++ (prettyTPTP $ f (VarFOL var)) ++ " )" ++
        " )"

    prettyTPTP TRUE  = "$true "
    prettyTPTP FALSE = "$false "

------------------------------------------------------------------------------
-- Pretty-printer for annotated formulas

instance PrettyTPTP RoleTPTP where
    prettyTPTP AxiomTPTP      = "axiom"
    prettyTPTP ConjectureTPTP = "conjecture"

instance PrettyTPTP AnnotatedFormula where
    prettyTPTP (AF qName roleTPTP formula) =
        "fof(" ++
        prettyTPTP qName ++ ", " ++
        prettyTPTP roleTPTP ++ ", " ++
        prettyTPTP formula ++
        ")." ++ "\n\n"
